import pandas as pd
from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
from underthesea import word_tokenize
import numpy as np
import torch
import re
from collections import Counter

# Try to import KeyBERT, fall back to simple extraction if it fails
try:
    from keybert import KeyBERT
    KEYBERT_AVAILABLE = True
    print("‚úÖ KeyBERT loaded successfully")
except ImportError as e:
    KEYBERT_AVAILABLE = False
    print(f"‚ö†Ô∏è KeyBERT not available. Using fallback keyword extraction")

# Load data
print("üìÇ Loading data...")
restaurants_df = pd.read_csv("restaurants_100_improved.csv")
menus_df = pd.read_csv("menus_100_improved.csv")

# Merge restaurant and menu data
print("üîó Merging restaurant and menu data...")
# Create a mapping from restaurant_id to restaurant info
restaurant_info = restaurants_df.set_index('restaurant_id')[['name', 'city', 'cuisine', 'price_range', 'rating', 'tags']].to_dict('index')

# Add restaurant info to menu items
menus_df['restaurant_name'] = menus_df['restaurant_id'].map(lambda x: restaurant_info.get(x, {}).get('name', 'Unknown'))
menus_df['city'] = menus_df['restaurant_id'].map(lambda x: restaurant_info.get(x, {}).get('city', 'Unknown'))
menus_df['cuisine'] = menus_df['restaurant_id'].map(lambda x: restaurant_info.get(x, {}).get('cuisine', 'Unknown'))
menus_df['restaurant_rating'] = menus_df['restaurant_id'].map(lambda x: restaurant_info.get(x, {}).get('rating', 0))
menus_df['restaurant_tags'] = menus_df['restaurant_id'].map(lambda x: restaurant_info.get(x, {}).get('tags', ''))
menus_df['price_range'] = menus_df['restaurant_id'].map(lambda x: restaurant_info.get(x, {}).get('price_range', '‚Ç´‚Ç´'))

# Clean data
for col in ['dish_name', 'category', 'description', 'tags', 'city', 'cuisine', 'restaurant_name', 'restaurant_tags']:
    if col in menus_df.columns:
        menus_df[col] = menus_df[col].fillna("").astype(str)

menus_df['price_vnd'] = pd.to_numeric(menus_df['price_vnd'], errors='coerce').fillna(0)
menus_df['restaurant_rating'] = pd.to_numeric(menus_df['restaurant_rating'], errors='coerce').fillna(0)

# Initialize models
print("ü§ñ Loading AI models...")
device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"   Using device: {device}")

embed_model = SentenceTransformer('paraphrase-multilingual-MiniLM-L12-v2', device=device)

# Initialize KeyBERT if available
if KEYBERT_AVAILABLE:
    try:
        kw_model = KeyBERT(model=embed_model)
        print("‚úÖ KeyBERT initialized")
    except Exception as e:
        print(f"‚ö†Ô∏è KeyBERT initialization failed: {e}")
        KEYBERT_AVAILABLE = False

# Vietnamese stop words
stop_words_vi = [
    'c·ªßa', 'v√†', 'c√°c', 'c√≥', 'ƒë∆∞·ª£c', 'cho', 'l√†', 'v·ªõi', 
    'ƒë·ªÉ', 'trong', 'kh√¥ng', 'm·ªôt', 'n√†y', 'nh·ªØng', 'ƒë√£', 
    'nh∆∞', 'b·ªüi', 't·ª´', 'ho·∫∑c', 'ƒë·∫øn', 'khi', 'c≈©ng', 'nh∆∞ng',
    'th√¨', 'n√†o', 'ƒë√¢y', 'r·∫•t', 's·∫Ω', 'v√†o', 'ra', '·ªü', 'v·ªÅ'
]

# Food keywords for better matching
food_keywords = {
    'ph·ªü': ['ph·ªü', 'pho'],
    'b√∫n': ['b√∫n', 'bun'],
    'c∆°m': ['c∆°m', 'com', 'rice', 'c∆°m t·∫•m'],
    'b√°nh m√¨': ['b√°nh m√¨', 'banh mi'],
    'nem': ['nem', 'ch·∫£ gi√≤', 'spring roll'],
    'g·ªèi': ['g·ªèi', 'salad', 'goi cuon'],
    'sushi': ['sushi', 'sashimi'],
    'ramen': ['ramen', 'm√¨ nh·∫≠t'],
    'bbq': ['bbq', 'n∆∞·ªõng', 'grilled', 'bulgogi'],
    'curry': ['curry', 'c√† ri'],
    'pasta': ['pasta', 'm·ª≥ √Ω', 'spaghetti'],
    'pizza': ['pizza'],
    'burger': ['burger', 'hamburger'],
    'steak': ['steak', 'b√≠t t·∫øt'],
    'chay': ['chay', 'vegetarian', 'vegan'],
    'h·∫£i s·∫£n': ['h·∫£i s·∫£n', 'seafood', 't√¥m', 'cua', 'c√°'],
    'g√†': ['g√†', 'chicken'],
    'b√≤': ['b√≤', 'beef'],
    'heo': ['heo', 'pork', 'l·ª£n'],
    'tr√°ng mi·ªáng': ['tr√°ng mi·ªáng', 'dessert', 'ng·ªçt', 'ch√®', 'kem'],
    'ƒë·ªì u·ªëng': ['ƒë·ªì u·ªëng', 'drink', 'n∆∞·ªõc', 'tr√†', 'c√† ph√™']
}

def simple_keyword_extraction(text, stop_words, top_n=10):
    """Fallback keyword extraction without KeyBERT"""
    text = text.lower()
    try:
        tokens = word_tokenize(text, format="text").split()
    except:
        tokens = text.split()
    
    tokens = [word for word in tokens if word not in stop_words and len(word) > 2]
    word_freq = Counter(tokens)
    keywords = [word for word, _ in word_freq.most_common(top_n)]
    return keywords

def extract_city(user_input):
    """Extract city from user input"""
    user_lower = user_input.lower()
    city_keywords = {
        "ƒê√† N·∫µng": ["ƒë√† n·∫µng", "da nang", "ƒën", "danang"],
        "H·ªì Ch√≠ Minh": ["h·ªì ch√≠ minh", "hcm", "s√†i g√≤n", "saigon", "tphcm", "tp hcm"],
        "H√† N·ªôi": ["h√† n·ªôi", "ha noi", "hn", "hanoi"],
        "Nha Trang": ["nha trang"],
        "ƒê√† L·∫°t": ["ƒë√† l·∫°t", "da lat", "dalat"],
        "C·∫ßn Th∆°": ["c·∫ßn th∆°", "can tho"],
        "Hu·∫ø": ["hu·∫ø", "hue"],
        "H·∫£i Ph√≤ng": ["h·∫£i ph√≤ng", "hai phong"],
        "V≈©ng T√†u": ["v≈©ng t√†u", "vung tau"],
        "Ph√∫ Qu·ªëc": ["ph√∫ qu·ªëc", "phu quoc"]
    }
    
    for city, keywords in city_keywords.items():
        if any(kw in user_lower for kw in keywords):
            return city
    return None

def extract_price_preference(user_input):
    """Extract price preference from user input"""
    user_lower = user_input.lower()
    
    cheap_keywords = ['r·∫ª', 'b√¨nh d√¢n', 'sinh vi√™n', 'ti·∫øt ki·ªám', 'budget', 'cheap', 'd∆∞·ªõi 100k', 'd∆∞·ªõi 100']
    mid_keywords = ['v·ª´a ph·∫£i', 'trung b√¨nh', 'h·ª£p l√Ω', '100k-200k']
    expensive_keywords = ['cao c·∫•p', 'sang tr·ªçng', 'ƒë·∫Øt', 'fine dining', 'luxury', 'tr√™n 200k']
    
    if any(kw in user_lower for kw in cheap_keywords):
        return 'cheap'  # < 100k
    elif any(kw in user_lower for kw in expensive_keywords):
        return 'expensive'  # > 200k
    elif any(kw in user_lower for kw in mid_keywords):
        return 'mid'  # 100k-200k
    return None

def extract_category(user_input):
    """Extract food category from user input"""
    user_lower = user_input.lower()
    
    if any(kw in user_lower for kw in ['khai v·ªã', 'appetizer', 'starter', 'g·ªèi', 'nem']):
        return 'Khai v·ªã'
    elif any(kw in user_lower for kw in ['m√≥n ch√≠nh', 'main', 'main course', 'b·ªØa ch√≠nh']):
        return 'M√≥n ch√≠nh'
    elif any(kw in user_lower for kw in ['tr√°ng mi·ªáng', 'dessert', 'ng·ªçt', 'ch√®', 'b√°nh ng·ªçt']):
        return 'Tr√°ng mi·ªáng'
    elif any(kw in user_lower for kw in ['ƒë·ªì u·ªëng', 'drink', 'n∆∞·ªõc', 'u·ªëng', 'tr√†', 'c√† ph√™']):
        return 'ƒê·ªì u·ªëng'
    return None

# Pre-compute food embeddings
print("üìä Pre-computing food embeddings...")
menus_df["search_text"] = (
    menus_df["dish_name"] + " " + 
    menus_df["description"] + " " + 
    menus_df["tags"] + " " + 
    menus_df["category"] + " " +
    menus_df["cuisine"] + " " +
    menus_df["restaurant_tags"]
)
food_embeddings = embed_model.encode(menus_df["search_text"].tolist(), show_progress_bar=True)
menus_df["embedding"] = list(food_embeddings)

print(f"‚úÖ Loaded {len(menus_df)} dishes from {restaurants_df['name'].nunique()} restaurants")

def recommend_food(user_input, city_filter=None, price_filter=None, category_filter=None, top_n=10):
    """Recommend food dishes based on user input"""
    
    if not user_input.strip():
        print("‚ö†Ô∏è Please tell me what you want to eat!")
        return pd.DataFrame()
    
    # Extract keywords
    try:
        if KEYBERT_AVAILABLE:
            tokenized_text = word_tokenize(user_input, format="text")
            keywords = kw_model.extract_keywords(
                tokenized_text,
                keyphrase_ngram_range=(1, 3),
                stop_words=stop_words_vi,
                top_n=10,
                use_mmr=True,
                diversity=0.7
            )
            user_keywords = [kw[0] for kw in keywords]
            print(f"üîë Keywords (KeyBERT): {user_keywords}")
        else:
            user_keywords = simple_keyword_extraction(user_input, stop_words_vi, top_n=10)
            print(f"üîë Keywords (Simple): {user_keywords}")
        
        if not user_keywords:
            user_keywords = [user_input]
    except Exception as e:
        print(f"‚ö†Ô∏è Keyword extraction failed: {e}")
        user_keywords = [user_input]
    
    # Encode user query
    search_query = " ".join(user_keywords)
    user_vec = embed_model.encode(search_query)
    
    # Calculate similarities
    similarities = cosine_similarity([user_vec], list(menus_df["embedding"]))[0]
    
    # Start with full dataframe
    filtered_df = menus_df.copy()
    
    # Filter by city
    if city_filter:
        filtered_df = filtered_df[filtered_df["city"].str.contains(city_filter, case=False, na=False)]
        print(f"üìç Filtering by city: {city_filter}")
    
    # Filter by price
    if price_filter:
        if price_filter == 'cheap':
            filtered_df = filtered_df[filtered_df["price_vnd"] < 100000]
            print(f"üí∞ Filtering by price: < 100,000 VNƒê")
        elif price_filter == 'mid':
            filtered_df = filtered_df[(filtered_df["price_vnd"] >= 100000) & (filtered_df["price_vnd"] <= 200000)]
            print(f"üí∞ Filtering by price: 100,000 - 200,000 VNƒê")
        elif price_filter == 'expensive':
            filtered_df = filtered_df[filtered_df["price_vnd"] > 200000]
            print(f"üí∞ Filtering by price: > 200,000 VNƒê")
    
    # Filter by category
    if category_filter:
        filtered_df = filtered_df[filtered_df["category"].str.contains(category_filter, case=False, na=False)]
        print(f"üçΩÔ∏è Filtering by category: {category_filter}")
    
    # Check if we have results
    if filtered_df.empty:
        print(f"‚ö†Ô∏è No dishes found with the specified filters.")
        print("üí° Try broadening your search criteria.")
        return pd.DataFrame()
    
    # Get similarities for filtered items
    filtered_indices = filtered_df.index
    filtered_similarities = similarities[filtered_indices]
    
    # Add similarity scores
    filtered_df = filtered_df.copy()
    filtered_df["similarity"] = filtered_similarities
    
    # Calculate final score (70% similarity + 30% restaurant rating)
    filtered_df["final_score"] = (
        0.7 * filtered_df["similarity"] + 
        0.3 * (filtered_df["restaurant_rating"] / 5.0)
    )
    
    # Get top recommendations
    recommendations = filtered_df.sort_values(by="final_score", ascending=False).head(top_n)
    
    # Display results
    print(f"\nüèÜ Top {len(recommendations)} recommended dishes:")
    print("=" * 90)
    
    for idx, (_, row) in enumerate(recommendations.iterrows(), 1):
        print(f"\n{idx}. üçΩÔ∏è {row['dish_name']} - {int(row['price_vnd']):,} VNƒê")
        print(f"   üè™ {row['restaurant_name']} ({row['city']})")
        print(f"   üç¥ {row['cuisine']} | üìÇ {row['category']}")
        print(f"   ‚≠ê Restaurant: {row['restaurant_rating']:.1f} | üéØ Match: {row['similarity']:.3f}")
        print(f"   üìù {row['description']}")
        print(f"   üè∑Ô∏è {row['tags']}")
    
    print("=" * 90)
    
    return recommendations[[
        "dish_name", "restaurant_name", "city", "cuisine", "category",
        "price_vnd", "description", "restaurant_rating", "similarity", "final_score"
    ]]

def interactive_food_search():
    """Interactive food search system"""
    print("\n" + "="*90)
    print("üçú VIETNAMESE FOOD RECOMMENDATION SYSTEM")
    print("="*90)
    print("\nTips: You can search by:")
    print("  ‚Ä¢ Dish name (e.g., 'ph·ªü', 'sushi', 'pizza')")
    print("  ‚Ä¢ Taste/Style (e.g., 'cay', 'ng·ªçt', 'chua', 'spicy')")
    print("  ‚Ä¢ City (e.g., 'H√† N·ªôi', 'S√†i G√≤n', 'ƒê√† N·∫µng')")
    print("  ‚Ä¢ Price (e.g., 'r·∫ª', 'budget', 'cao c·∫•p')")
    print("  ‚Ä¢ Category (e.g., 'm√≥n ch√≠nh', 'tr√°ng mi·ªáng', 'ƒë·ªì u·ªëng')")
    
    user_input = input("\nüó£Ô∏è B·∫°n mu·ªën ƒÉn g√¨ h√¥m nay? (What do you want to eat?): ").strip()
    
    if not user_input:
        print("‚ö†Ô∏è Please enter something!")
        return
    
    # Auto-extract filters
    city = extract_city(user_input)
    price = extract_price_preference(user_input)
    category = extract_category(user_input)
    
    # Display detected filters
    print("\nüîç Analyzing your request...")
    if city:
        print(f"‚úÖ Detected city: {city}")
    if price:
        print(f"‚úÖ Detected price preference: {price}")
    if category:
        print(f"‚úÖ Detected category: {category}")
    
    # Get recommendations
    results = recommend_food(
        user_input,
        city_filter=city,
        price_filter=price,
        category_filter=category,
        top_n=10
    )
    
    # Options
    if not results.empty:
        print("\nüí¨ Options:")
        print("  1. New search (type 'new')")
        print("  2. Filter by city (type city name)")
        print("  3. Show cheaper options (type 'cheap')")
        print("  4. Show more expensive options (type 'expensive')")
        print("  5. Exit (type 'exit')")
        
        choice = input("\nYour choice: ").strip().lower()
        
        if choice == 'new':
            interactive_food_search()
        elif choice == 'cheap':
            recommend_food(user_input, city_filter=city, price_filter='cheap', category_filter=category, top_n=10)
        elif choice == 'expensive':
            recommend_food(user_input, city_filter=city, price_filter='expensive', category_filter=category, top_n=10)
        elif choice in ['ƒë√† n·∫µng', 'h√† n·ªôi', 'h·ªì ch√≠ minh', 's√†i g√≤n', 'nha trang']:
            city_map = {
                's√†i g√≤n': 'H·ªì Ch√≠ Minh',
                'h·ªì ch√≠ minh': 'H·ªì Ch√≠ Minh',
                'h√† n·ªôi': 'H√† N·ªôi',
                'ƒë√† n·∫µng': 'ƒê√† N·∫µng',
                'nha trang': 'Nha Trang'
            }
            recommend_food(user_input, city_filter=city_map.get(choice, choice.title()), price_filter=price, category_filter=category, top_n=10)
        elif choice != 'exit':
            print("Thanks for using the system! üëã")

if __name__ == "__main__":
    interactive_food_search()